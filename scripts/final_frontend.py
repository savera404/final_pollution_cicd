# -*- coding: utf-8 -*-
"""final_frontend.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nO_2cNw606htVxDk7R3T7-4Mdy0NRLyK
"""

!pip install hopsworks==4.2.* joblib streamlit pyngrok -q

pip install scikit-learn==1.7.2

from pyngrok import ngrok
ngrok.set_auth_token("2zXwYhDc2yafWKJApl8INtp9hbh_3MUxJTnu1fp8TFgaXFpuJ")

from google.colab import userdata
import os

# Get secret from Colab storage
HOPSWORKS_API_KEY = userdata.get("HOPSWORKS_API_KEY")
OPENWEATHER_API_KEY = userdata.get("OPENWEATHER_API_KEY")

# Save it to environment variable so Streamlit can access it
os.environ["HOPSWORKS_API_KEY"] = HOPSWORKS_API_KEY
os.environ["OPENWEATHER_API_KEY"] = OPENWEATHER_API_KEY

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import hopsworks
# import joblib
# import os
# import pandas as pd
# import numpy as np
# import requests
# import json  # üî• FIX 1: Add missing import
# 
# # ---------------------- AQI CALCULATION LOGIC ----------------------
# def calculate_aqi_single_pollutant(concentration, pollutant):
#     """Calculate AQI for a single pollutant using breakpoints (EPA standard)"""
#     breakpoints = {
#         'pm2_5': [
#             (0.0, 12.0, 0, 50),
#             (12.1, 35.4, 51, 100),
#             (35.5, 55.4, 101, 150),
#             (55.5, 150.4, 151, 200),
#             (150.5, 250.4, 201, 300),
#             (250.5, 500.4, 301, 500)
#         ],
#         'pm10': [
#             (0, 54, 0, 50),
#             (55, 154, 51, 100),
#             (155, 254, 101, 150),
#             (255, 354, 151, 200),
#             (355, 424, 201, 300),
#             (425, 604, 301, 500)
#         ],
#         'no2': [
#             (0, 53, 0, 50),
#             (54, 100, 51, 100),
#             (101, 360, 101, 150),
#             (361, 649, 151, 200),
#             (650, 1249, 201, 300),
#             (1250, 2049, 301, 500)
#         ],
#         'so2': [
#             (0, 35, 0, 50),
#             (36, 75, 51, 100),
#             (76, 185, 101, 150),
#             (186, 304, 151, 200),
#             (305, 604, 201, 300),
#             (605, 1004, 301, 500)
#         ],
#         'o3': [
#             (0.000, 0.054, 0, 50),
#             (0.055, 0.070, 51, 100),
#             (0.071, 0.085, 101, 150),
#             (0.086, 0.105, 151, 200),
#             (0.106, 0.200, 201, 300)
#         ],
#         'co': [
#             (0.0, 4.4, 0, 50),
#             (4.5, 9.4, 51, 100),
#             (9.5, 12.4, 101, 150),
#             (12.5, 15.4, 151, 200),
#             (15.5, 30.4, 201, 300),
#             (30.5, 50.4, 301, 500)
#         ]
#     }
# 
#     if pollutant not in breakpoints:
#         return np.nan
# 
#     for bp in breakpoints[pollutant]:
#         c_low, c_high, aqi_low, aqi_high = bp
#         if c_low <= concentration <= c_high:
#             return ((aqi_high - aqi_low) / (c_high - c_low)) * (concentration - c_low) + aqi_low
# 
#     return np.nan
# 
# 
# def calculate_overall_aqi(row):
#     """Calculate overall AQI and dominant pollutant"""
#     pollutants = {
#         'pm2_5': row.get('pm2_5', np.nan),
#         'pm10': row.get('pm10', np.nan),
#         'o3': row.get('o3', np.nan),
#         'no2': row.get('no2', np.nan),
#         'so2': row.get('so2', np.nan),
#         'co': row.get('co', np.nan)
#     }
# 
#     aqi_values = {}
#     for pollutant, concentration in pollutants.items():
#         if pd.notna(concentration) and concentration >= 0:
#             aqi_values[pollutant] = calculate_aqi_single_pollutant(concentration, pollutant)
# 
#     if not aqi_values:
#         return {'aqi': np.nan, 'dominant_pollutant': None}
# 
#     dominant_pollutant = max(aqi_values, key=aqi_values.get)
#     overall_aqi = aqi_values[dominant_pollutant]
# 
#     return {
#         'aqi': overall_aqi,
#         'dominant_pollutant': dominant_pollutant,
#         **{f'aqi_{k}': v for k, v in aqi_values.items()}
#     }
# 
# 
# # ---------------------- HOPSWORKS MODEL SETUP ----------------------
# HOPSWORKS_API_KEY = os.environ.get("HOPSWORKS_API_KEY")
# project = hopsworks.login(api_key_value=HOPSWORKS_API_KEY)
# mr = project.get_model_registry()
# 
# st.title("üåø Real-Time Air Quality Prediction Dashboard")
# 
# # --- Model Selection ---
# model_choice = st.selectbox(
#     "Select Model:",
#     ["aqi_gradient_boosting", "aqi_random_forest", "aqi_xgboost"]
# )
# 
# # Download model
# model = mr.get_model(model_choice, version=1)
# model_dir = model.download()
# 
# # Extract model type from name (e.g., "aqi_gradient_boosting" -> "gradient_boosting")
# model_type = "_".join(model_choice.split("_")[1:])
# 
# # üî• CRITICAL: Load model, scaler, AND features
# regressor = joblib.load(f"{model_dir}/{model_type}_model.pkl")
# scaler = joblib.load(f"{model_dir}/{model_type}_scaler.pkl")
# 
# # üî• FIX 2: Load feature names and USE them (don't hardcode later)
# with open(f"{model_dir}/{model_type}_features.json", 'r') as f:
#     model_features = json.load(f)['features']  # Renamed to model_features
# 
# st.success(f"‚úÖ Loaded {model_choice} with {len(model_features)} features")
# 
# 
# # ---------------------- FIXED OPENWEATHER FETCH ----------------------
# st.header("üåç Karachi: Predicted vs Actual AQI Comparison")
# 
# # ‚úÖ Fixed Karachi coordinates
# lat = 24.8607
# lon = 67.0011
# 
# # ‚úÖ Fetch API key from environment
# OPENWEATHER_API_KEY = os.environ.get("OPENWEATHER_API_KEY")
# 
# if st.button("Fetch Karachi AQI Data"):
#     try:
#         url = f"http://api.openweathermap.org/data/2.5/air_pollution?lat={lat}&lon={lon}&appid={OPENWEATHER_API_KEY}"
#         response = requests.get(url)
#         data = response.json()
# 
#         components = data["list"][0]["components"]
# 
#         # --- Calculate Actual AQI using EPA formula ---
#         result = calculate_overall_aqi(pd.Series(components))
#         actual_aqi = result["aqi"]
#         dominant = result["dominant_pollutant"]
# 
#         # --- Prepare base pollutants ---
#         pollutants = {
#             "pm2_5": float(components.get("pm2_5", 0.0)),
#             "pm10": float(components.get("pm10", 0.0)),
#             "no2": float(components.get("no2", 0.0)),
#             "so2": float(components.get("so2", 0.0)),
#             "o3": float(components.get("o3", 0.0)),
#             "co": float(components.get("co", 0.0)),
#             "nh3": float(components.get("nh3", 0.0)),
#             "no": float(components.get("no", 0.0))
#         }
# 
#         # üîß Create all engineered features
#         input_data = {}
# 
#         # Base pollutants
#         input_data.update(pollutants)
# 
#         # Derived features
#         input_data["total_pm"] = pollutants["pm2_5"] + pollutants["pm10"]
#         input_data["total_gases"] = (pollutants["co"] + pollutants["o3"] +
#                                      pollutants["so2"] + pollutants["no2"] + pollutants["no"])
#         input_data["pm_ratio"] = pollutants["pm2_5"] / (pollutants["pm10"] + 1e-6)
#         input_data["nox_ratio"] = pollutants["no2"] / (pollutants["no"] + pollutants["no2"] + 1e-6)
# 
#         # Rolling averages (approximate with current values)
#         input_data["pm2_5_rolling_3"] = pollutants["pm2_5"]
#         input_data["pm10_rolling_3"] = pollutants["pm10"]
#         input_data["no_rolling_3"] = pollutants["no"]
#         input_data["no2_rolling_3"] = pollutants["no2"]
#         input_data["co_rolling_3"] = pollutants["co"]
#         input_data["so2_rolling_3"] = pollutants["so2"]
#         input_data["o3_rolling_3"] = pollutants["o3"]
# 
#         # Binary indicators (EPA thresholds)
#         input_data["pm2_5_high"] = float(1 if pollutants["pm2_5"] > 35.4 else 0)
#         input_data["pm10_high"] = float(1 if pollutants["pm10"] > 154 else 0)
# 
#         # Temporal feature
#         input_data["month"] = float(pd.Timestamp.now().month)
# 
#         # üî• FIX 2: Use the loaded model_features (don't hardcode again!)
#         # Create DataFrame in exact order from the loaded features JSON
#         input_df = pd.DataFrame([{feat: input_data.get(feat, 0.0) for feat in model_features}])
# 
#         # üî• FIX 3: Apply scaler BEFORE prediction
#         input_scaled = scaler.transform(input_df)
# 
#         # --- Predict AQI ---
#         predicted_aqi = regressor.predict(input_scaled)[0]
# 
#         # Clip to valid AQI range
#         predicted_aqi = np.clip(predicted_aqi, 0, 500)
# 
#         # Display results
#         st.subheader("üìä Comparison Results for Karachi")
# 
#         col1, col2, col3 = st.columns(3)
# 
#         with col1:
#             st.metric("Actual AQI (EPA formula)", f"{actual_aqi:.2f}")
# 
#         with col2:
#             st.metric("Predicted AQI (Model)", f"{predicted_aqi:.2f}")
# 
#         with col3:
#             diff = abs(predicted_aqi - actual_aqi)
#             pct_error = (diff / actual_aqi * 100) if actual_aqi > 0 else 0
#             st.metric("Difference", f"{diff:.2f}",
#                      delta=f"{pct_error:.1f}% error",
#                      delta_color="inverse")
# 
#         # Show dominant pollutant
#         st.info(f"üî¨ **Dominant Pollutant:** {dominant.upper()}")
# 
#         # Show raw pollutant values
#         with st.expander("üîç View Raw Pollutant Data"):
#             st.json(components)
# 
#         # Debug panel
#         with st.expander("üîß Debug: Feature Engineering"):
#             col1, col2 = st.columns(2)
# 
#             with col1:
#                 st.write("**Unscaled Features:**")
#                 st.dataframe(input_df.head())
# 
#             with col2:
#                 st.write("**Scaled Features (Model Input):**")
#                 scaled_df = pd.DataFrame(input_scaled, columns=model_features)
#                 st.dataframe(scaled_df.head())
# 
#     except Exception as e:
#         st.error(f"‚ùå Error fetching data: {str(e)}")
#         import traceback
#         st.code(traceback.format_exc())

from pyngrok import ngrok
public_url = ngrok.connect(8501)
print("üîó Streamlit App URL:", public_url)
!streamlit run app.py --server.enableCORS false --server.enableXsrfProtection false --server.port 8501 &